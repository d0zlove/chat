#include "animation_system.h"
#include "..\ragebot\aim.h"

void resolver::initialize(player_t* e, adjust_data* record, const float& goal_feet_yaw, const float& pitch)
{
	player = e;
	player_record = record;

	original_goal_feet_yaw = math::normalize_yaw(goal_feet_yaw);
	original_pitch = math::normalize_pitch(pitch);
}

void resolver::reset()
{
	player = nullptr;
	player_record = nullptr;

	side = false;
	fake = false;

	original_goal_feet_yaw = 0.0f;
	original_pitch = 0.0f;
}



void resolver::instance(player_t* e, bool moved, bool LowDelta) {
	adjust_data lag_record;

	if (moved) {
		if (LowDelta) {
			check_low_delta_desync(e, lag_record);
		}
		else{
			resolve_moves(e, lag_record);
			setup_resolver_layers(e, lag_record, lag_record.m_rotation_mode);
		}
	}
	else{
		if (LowDelta) {
			check_low_delta_desync(e, lag_record);
		}
		else{
		resolve_stand(e, lag_record);
		set_abs_angles_and_bones(e, lag_record.m_rotation_mode);
		}
	}

	if (!lag_record.m_rotation_mode) {
		if (g_ctx.globals.missed_shots[e->EntIndex()] > 1)
		{
			auto new_rotation = ROTATE_SERVER;

			switch (lag_record.m_rotation_mode)
			{
			case ROTATE_LEFT: new_rotation = ROTATE_RIGHT;
				break;
			case ROTATE_RIGHT: new_rotation = ROTATE_LOW_RIGHT;
				break;
			case ROTATE_LOW_RIGHT: new_rotation = ROTATE_LOW_LEFT;
				break;
			case ROTATE_LOW_LEFT: new_rotation = ROTATE_LEFT;
				break;
			default: break;
			}

			lag_record.m_rotation_mode = new_rotation;
		}
	}
}

void resolver::resolve_stand(player_t* player, adjust_data& lag_record)
{

	const auto feet_delta = math::normalize_yaw(math::AngleDiff(math::normalize_yaw(player->m_flLowerBodyYawTarget()), math::normalize_yaw(player->m_angEyeAngles().y)));

	const auto eye_diff = math::AngleDiff(player->m_angEyeAngles().y, player->get_animation_state()->m_flGoalFeetYaw);

	bool stopped_moving{};

	bool balance_adjust{};

	bool stopped_moving_this_frame = false;
	if (player->get_animation_state()->m_velocity <= 0.1f)
	{
		stopped_moving_this_frame = true;
		player->get_animation_state()->m_duration_still += player->get_animation_state()->m_last_update_increment;
	}

	if (player->get_animation_state()->m_ladder_weight == 0.0f &&
		player->get_animation_state()->m_last_update_increment > 0.0f)
	{
		const auto current_feet_yaw = player->get_animation_state()->m_flCurrentFeetYaw;
		const auto goal_feet_yaw = player->get_animation_state()->m_flGoalFeetYaw;
		auto eye_delta = current_feet_yaw - goal_feet_yaw;

		if (goal_feet_yaw < current_feet_yaw)
		{
			if (eye_delta >= 180.0f)
				eye_delta -= 360.0f;
		}
		else if (eye_delta <= -180.0f)
			eye_delta += 360.0f;

		if (eye_delta / player->get_animation_state()->m_last_update_increment > 120.f)
		{
			balance_adjust = true;
			player->get_animation_state()->m_adjust_started = true;
		}
	}

	if (!player->get_animation_state()->m_adjust_started && stopped_moving_this_frame && player->get_animation_state()->m_bOnGround && player->get_animation_state()->m_ladder_weight == 0.0f)
	{
		stopped_moving = true;
		player->get_animation_state()->m_adjust_started = true;
	}

	if (stopped_moving || balance_adjust || player->get_animation_state()->m_adjust_started)
	{

		lag_record.m_rotation_mode = feet_delta > 0.0f && eye_diff > 0.0f ? ROTATE_LEFT : ROTATE_RIGHT;

		lag_record.m_feet_delta = feet_delta;

		player->get_animation_state()->m_flGoalFeetYaw = math::ApproachAngle(player->m_flLowerBodyYawTarget(), player->get_animation_state()->m_flGoalFeetYaw, player->get_animation_state()->m_last_update_increment * 100.0f);
	}
}

//z = m_velocity
//xy = m_flUpcvelocity

void resolver::resolve_moves(player_t* player, adjust_data& lag_record)
{
	if (const auto eye_diff = math::normalize_yaw(math::AngleDiff(player->m_angEyeAngles().y, player->get_animation_state()->m_flGoalFeetYaw)); eye_diff > player->get_max_desync_delta())
	{
		lag_record.m_rotation_mode = ROTATE_LOW_RIGHT;
	}
	else
	{
		lag_record.m_rotation_mode = ROTATE_LOW_LEFT;
	}

	player->get_animation_state()->m_flGoalFeetYaw = math::ApproachAngle(player->m_angEyeAngles().y, player->get_animation_state()->m_flGoalFeetYaw, (player->get_animation_state()->m_walk_to_run_transition * 20.0f + 30.0f) * player->get_animation_state()->m_last_update_increment);
}

void resolver::setup_resolver_layers(player_t* player, adjust_data& lag_record, const int32_t rotation_mode)
{
	switch (rotation_mode)
	{
	case ROTATE_SERVER:
	{
		memcpy(lag_record.m_resolver_layers.at(S_SERVER).data(), player->get_animlayers(),
			sizeof(AnimationLayer) * ANIMATION_LAYER_COUNT);
	}
	break;
	case ROTATE_LEFT:
	case ROTATE_LOW_LEFT:
	{
		memcpy(lag_record.m_resolver_layers.at(S_LEFT).data(), player->get_animlayers(),
			sizeof(AnimationLayer) * ANIMATION_LAYER_COUNT);
	}
	break;
	case ROTATE_RIGHT:
	case ROTATE_LOW_RIGHT:
	{
		memcpy(lag_record.m_resolver_layers.at(S_RIGHT).data(), player->get_animlayers(),
			sizeof(AnimationLayer) * ANIMATION_LAYER_COUNT);
	}
	break;
	default: {
	}
		   break;
	}
}

void resolver::set_abs_angles_and_bones(player_t* player, const int32_t rotation_mode)
{
	switch (rotation_mode)
	{
	case ROTATE_LEFT:
	{
		player->get_animation_state()->m_flGoalFeetYaw = math::normalize_yaw(player->m_angEyeAngles().y + 60);
	}
	break;
	case ROTATE_RIGHT:
	{
		player->get_animation_state()->m_flGoalFeetYaw = math::normalize_yaw(player->m_angEyeAngles().y - 60);
	}
	break;
	default:
		break;
	}

	return player->invalidate_physics_recursive(ANGLES_CHANGED);
}

/* check low desync delta defines */
#define delta(angle1, angle2) remainderf(fabsf(angle1 - angle2), 360.0f)
#define n(yaw) math::normalize_yaw(fabsf(yaw))
#define ca(angle1, angle2) math::calculate_angle(angle1, angle2)

/* check low desync delta */
void resolver::check_low_delta_desync(player_t* player, adjust_data& lag_record) {
	/* setup animstate */
	auto animstate = player->get_animation_state();

	/* setup desync delta vars */
	static float fl_stored_yaw = player->m_angEyeAngles().y;
	float fl_eye_yaw = player->m_angEyeAngles().y;
	float fl_lby_yaw = player->m_flLowerBodyYawTarget();
	float fl_desync_delta = delta(fl_eye_yaw, animstate->m_flGoalFeetYaw);
	fl_desync_delta = std::clamp(fl_desync_delta, -60.f, 60.f);

	/* setup target side */
	float fl_left_yaw = n(fl_eye_yaw - 60.0);
	float fl_right_yaw = n(fl_eye_yaw + 60.0);

	/* setup low delta */
	float fl_left_low_delta = n(fl_lby_yaw - 35.0);
	float fl_right_low_delta = n(fl_lby_yaw + 35.0);

	/* setup low desync checker */
	if (fabs(fl_desync_delta) < 35.f) {
		/* settup missed shots */
		switch (g_ctx.globals.missed_shots[player->EntIndex()] % 3) {
		case 0: {
			animstate->m_flGoalFeetYaw = fl_stored_brute[player->EntIndex()];
		} break;
		case 1: {
			animstate->m_flGoalFeetYaw = fl_left_low_delta;
			fl_stored_brute[player->EntIndex()] = fl_left_low_delta;
		} break;
		case 2: {
			animstate->m_flGoalFeetYaw = fl_right_low_delta;
			fl_stored_brute[player->EntIndex()] = fl_right_low_delta;
		} break;
		}
	}

	/* fixing moving delta vars */
	auto target_yaw = math::calculate_angle(g_ctx.local()->m_vecOrigin(), player->m_vecOrigin()).y;
	auto target_left_direction = math::normalize_yaw(target_yaw - fl_left_yaw);
	auto target_right_direction = math::normalize_yaw(target_yaw - fl_right_yaw);

	/* fixing moving delta */
	if (target_left_direction > target_right_direction) {
		/* positive right target */
		animstate->m_flGoalFeetYaw = fl_right_yaw;
	}
	else {
		/* negative left target */
		animstate->m_flGoalFeetYaw = fl_left_yaw;
	}

	/* get stored yaw */
	if (fl_stored_yaw != fl_eye_yaw) {
		if (animstate->m_flCurrentFeetYaw != animstate->m_flGoalFeetYaw) {
			fl_stored_yaw = player->m_angEyeAngles().y;
			animstate->m_flCurrentFeetYaw = animstate->m_flGoalFeetYaw;
			animstate->m_flGoalFeetYaw = animstate->m_flFeetYawRate;
		}
	}

	/* check animrate */
	if (animstate->m_flFeetYawRate != 0) {
		/* check positive */
		if (animstate->m_flFeetYawRate == 60.0 || animstate->m_flFeetYawRate > 60.0) {
			animstate->m_flGoalFeetYaw = fl_right_yaw;
		}
		else if (animstate->m_flFeetYawRate == -60.0 || animstate->m_flFeetYawRate < -60.0) {
			animstate->m_flGoalFeetYaw = fl_left_yaw;
		}
	}

	/* check last desync delta ticks */
	if (fabs(fl_desync_delta) > 60.0) {
		if (fabs(fl_desync_delta) > 0) {
			animstate->m_flGoalFeetYaw = fl_left_yaw;
		}
		else {
			animstate->m_flGoalFeetYaw = fl_right_yaw;
		}
	}
	else if (fabs(fl_desync_delta) < -60.0) {
		if (fabs(fl_desync_delta) > 0) {
			animstate->m_flGoalFeetYaw = fl_right_yaw;
		}
		else {
			animstate->m_flGoalFeetYaw = fl_left_yaw;
		}
	}

	/* check if low delta was wrong */
	if (g_ctx.globals.missed_shots[player->EntIndex()] == 1 && fl_stored_brute[player->EntIndex()] == fl_left_yaw) {
		animstate->m_flGoalFeetYaw = fl_right_yaw;
	}
	else if (g_ctx.globals.missed_shots[player->EntIndex()] == 1 && fl_stored_brute[player->EntIndex()] == fl_right_yaw) {
		animstate->m_flGoalFeetYaw = fl_left_yaw;
	}

	/* bruteforce if check was wrong */
	switch (g_ctx.globals.missed_shots[player->EntIndex()] % 3) {
	case 0: {
		animstate->m_flGoalFeetYaw = fl_stored_brute[player->EntIndex()];
	} break;
	case 1: {
		animstate->m_flGoalFeetYaw = fl_left_low_delta;
		fl_stored_brute[player->EntIndex()] = fl_left_low_delta;
	} break;
	case 2: {
		animstate->m_flGoalFeetYaw = fl_right_low_delta;
		fl_stored_brute[player->EntIndex()] = fl_right_low_delta;
	} break;
	}
}

float resolver::resolve_pitch(player_t* e)
{
	return original_pitch;
}
